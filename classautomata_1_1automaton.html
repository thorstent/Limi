<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Limi: automata::automaton&lt; State, Symbol, Implementation &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Limi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>automata</b></li><li class="navelem"><a class="el" href="classautomata_1_1automaton.html">automaton</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classautomata_1_1automaton-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">automata::automaton&lt; State, Symbol, Implementation &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Automata need to inherit from this class and implement certain methods.  
 <a href="classautomata_1_1automaton.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="automaton_8h_source.html">automaton.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2594c2617e9311418b9b3686d1c0dcfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a2594c2617e9311418b9b3686d1c0dcfb">automaton</a> (bool <a class="el" href="classautomata_1_1automaton.html#ac21ed4659ff3d9f78bd1c94fdd6b174f">collapse_epsilon</a>=false, bool <a class="el" href="classautomata_1_1automaton.html#aad75ca183e68012b4f20da1b8acd0486">use_cache</a>=true, bool <a class="el" href="classautomata_1_1automaton.html#a63af1ca5a4bead7df8febae72fac4e72">no_epsilon_produced</a>=false)</td></tr>
<tr class="memdesc:a2594c2617e9311418b9b3686d1c0dcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a2594c2617e9311418b9b3686d1c0dcfb">More...</a><br/></td></tr>
<tr class="separator:a2594c2617e9311418b9b3686d1c0dcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b08886203176cf7f46f27cd30282f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#aa2b08886203176cf7f46f27cd30282f8">is_final_state</a> (const State &amp;state) const </td></tr>
<tr class="memdesc:aa2b08886203176cf7f46f27cd30282f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Implement</b> This function determines if a specific state is final.  <a href="#aa2b08886203176cf7f46f27cd30282f8">More...</a><br/></td></tr>
<tr class="separator:aa2b08886203176cf7f46f27cd30282f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e63c54b3eddddaf7b9974035453ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#aa5e63c54b3eddddaf7b9974035453ccf">initial_states</a> (State_set &amp;states) const </td></tr>
<tr class="memdesc:aa5e63c54b3eddddaf7b9974035453ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Implement</b> Returns the initial states.  <a href="#aa5e63c54b3eddddaf7b9974035453ccf">More...</a><br/></td></tr>
<tr class="separator:aa5e63c54b3eddddaf7b9974035453ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d36cd4ad67af0fb989c41ac18d30f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a47d36cd4ad67af0fb989c41ac18d30f4">successors</a> (const State &amp;state, const Symbol &amp;sigma, State_set &amp;successors1) const </td></tr>
<tr class="memdesc:a47d36cd4ad67af0fb989c41ac18d30f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Implement</b> Returns the successor for a specific state.  <a href="#a47d36cd4ad67af0fb989c41ac18d30f4">More...</a><br/></td></tr>
<tr class="separator:a47d36cd4ad67af0fb989c41ac18d30f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bafc87e4d1bf1a325f819a27f9c26f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a07bafc87e4d1bf1a325f819a27f9c26f">next_symbols</a> (const State &amp;state, Symbol_set &amp;symbols) const </td></tr>
<tr class="memdesc:a07bafc87e4d1bf1a325f819a27f9c26f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Implement</b> Returns possible successor symbols for a state.  <a href="#a07bafc87e4d1bf1a325f819a27f9c26f">More...</a><br/></td></tr>
<tr class="separator:a07bafc87e4d1bf1a325f819a27f9c26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04f43b2f0560b17cd07e544567ffb19"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structdatastructures_1_1printer__base.html">datastructures::printer_base</a><br class="typebreak"/>
&lt; State &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#aa04f43b2f0560b17cd07e544567ffb19">state_printer</a> () const </td></tr>
<tr class="memdesc:aa04f43b2f0560b17cd07e544567ffb19"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Implement</b> Returns a printer for states.  <a href="#aa04f43b2f0560b17cd07e544567ffb19">More...</a><br/></td></tr>
<tr class="separator:aa04f43b2f0560b17cd07e544567ffb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a9de347cc7a424b2ce939e11888098"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structdatastructures_1_1printer__base.html">datastructures::printer_base</a><br class="typebreak"/>
&lt; Symbol &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a57a9de347cc7a424b2ce939e11888098">symbol_printer</a> () const </td></tr>
<tr class="memdesc:a57a9de347cc7a424b2ce939e11888098"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Implement</b> Returns a printer for symbols.  <a href="#a57a9de347cc7a424b2ce939e11888098">More...</a><br/></td></tr>
<tr class="separator:a57a9de347cc7a424b2ce939e11888098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6d0723b7cde3bb90ad6a5504fb1aad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a4d6d0723b7cde3bb90ad6a5504fb1aad">is_epsilon</a> (const Symbol &amp;symbol) const </td></tr>
<tr class="memdesc:a4d6d0723b7cde3bb90ad6a5504fb1aad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Implement</b> Determines if a symbol should be considered an epsilon transition.  <a href="#a4d6d0723b7cde3bb90ad6a5504fb1aad">More...</a><br/></td></tr>
<tr class="separator:a4d6d0723b7cde3bb90ad6a5504fb1aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc91b4613822227e8550d05257649d66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#adc91b4613822227e8550d05257649d66">is_final_state</a> (const State_set &amp;states) const </td></tr>
<tr class="memdesc:adc91b4613822227e8550d05257649d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if one of the states is final.  <a href="#adc91b4613822227e8550d05257649d66">More...</a><br/></td></tr>
<tr class="separator:adc91b4613822227e8550d05257649d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd24d2830fb78d22594dd7a41cfea00a"><td class="memItemLeft" align="right" valign="top">State_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#abd24d2830fb78d22594dd7a41cfea00a">successors</a> (const State_set &amp;states, const Symbol &amp;sigma) const </td></tr>
<tr class="memdesc:abd24d2830fb78d22594dd7a41cfea00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds successors for a set of states.  <a href="#abd24d2830fb78d22594dd7a41cfea00a">More...</a><br/></td></tr>
<tr class="separator:abd24d2830fb78d22594dd7a41cfea00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c737fc524a5231e5aabeadda03d76e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a8c737fc524a5231e5aabeadda03d76e8">successors</a> (const State_set &amp;states, const Symbol &amp;sigma, State_set &amp;successors1) const </td></tr>
<tr class="memdesc:a8c737fc524a5231e5aabeadda03d76e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns successors for a set of states.  <a href="#a8c737fc524a5231e5aabeadda03d76e8">More...</a><br/></td></tr>
<tr class="separator:a8c737fc524a5231e5aabeadda03d76e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfcf0fd0d14c6494b73da5e991fe488"><td class="memItemLeft" align="right" valign="top">State_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a4bfcf0fd0d14c6494b73da5e991fe488">initial_states</a> () const </td></tr>
<tr class="memdesc:a4bfcf0fd0d14c6494b73da5e991fe488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of initial states.  <a href="#a4bfcf0fd0d14c6494b73da5e991fe488">More...</a><br/></td></tr>
<tr class="separator:a4bfcf0fd0d14c6494b73da5e991fe488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b70685fde44d22f1bae00c209fb0b63"><td class="memItemLeft" align="right" valign="top">State_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a9b70685fde44d22f1bae00c209fb0b63">successors</a> (const State &amp;state, const Symbol &amp;sigma) const </td></tr>
<tr class="memdesc:a9b70685fde44d22f1bae00c209fb0b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns successors for a state.  <a href="#a9b70685fde44d22f1bae00c209fb0b63">More...</a><br/></td></tr>
<tr class="separator:a9b70685fde44d22f1bae00c209fb0b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2619ba03fc85cfd9bd99d68f8c8273"><td class="memItemLeft" align="right" valign="top">Symbol_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a8a2619ba03fc85cfd9bd99d68f8c8273">next_symbols</a> (const State &amp;state) const </td></tr>
<tr class="memdesc:a8a2619ba03fc85cfd9bd99d68f8c8273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns possible successor symbols of a state.  <a href="#a8a2619ba03fc85cfd9bd99d68f8c8273">More...</a><br/></td></tr>
<tr class="separator:a8a2619ba03fc85cfd9bd99d68f8c8273"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac21ed4659ff3d9f78bd1c94fdd6b174f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac21ed4659ff3d9f78bd1c94fdd6b174f"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#ac21ed4659ff3d9f78bd1c94fdd6b174f">collapse_epsilon</a></td></tr>
<tr class="memdesc:ac21ed4659ff3d9f78bd1c94fdd6b174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true during exploration of the next state the epsilons will be fully explored. If false then epsilon transitions may be returned. <br/></td></tr>
<tr class="separator:ac21ed4659ff3d9f78bd1c94fdd6b174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad75ca183e68012b4f20da1b8acd0486"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad75ca183e68012b4f20da1b8acd0486"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#aad75ca183e68012b4f20da1b8acd0486">use_cache</a></td></tr>
<tr class="memdesc:aad75ca183e68012b4f20da1b8acd0486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow caching of successor relationships. <br/></td></tr>
<tr class="separator:aad75ca183e68012b4f20da1b8acd0486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63af1ca5a4bead7df8febae72fac4e72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63af1ca5a4bead7df8febae72fac4e72"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautomata_1_1automaton.html#a63af1ca5a4bead7df8febae72fac4e72">no_epsilon_produced</a></td></tr>
<tr class="memdesc:a63af1ca5a4bead7df8febae72fac4e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the implementation of <a class="el" href="classautomata_1_1automaton.html#a07bafc87e4d1bf1a325f819a27f9c26f" title="Implement Returns possible successor symbols for a state. ">next_symbols(const State&amp;,Symbol_set&amp;) const </a>will never produce epsilon transitions. <br/></td></tr>
<tr class="separator:a63af1ca5a4bead7df8febae72fac4e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class State, class Symbol, class Implementation&gt;<br/>
class automata::automaton&lt; State, Symbol, Implementation &gt;</h3>

<p>Automata need to inherit from this class and implement certain methods. </p>
<p>We use the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">curiously recurring template pattern (CRTP)</a>. This means that the custom automaton must inherit from this class and pass itself as the Implementation template argument. Furthermore none of the methods should be declared virtual (virtual function calls are too slow) and small functions should be declared inline if possible. Functions that need to be implemented by the deriving class are marked as <b>Implement</b>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">State</td><td>The state class that the automaton will use. </td></tr>
    <tr><td class="paramname">Symbol</td><td>The symbol class. </td></tr>
    <tr><td class="paramname">Implementation</td><td>The deriving class must pass its own name here. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2594c2617e9311418b9b3686d1c0dcfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::<a class="el" href="classautomata_1_1automaton.html">automaton</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collapse_epsilon</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_cache</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_epsilon_produced</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collapse_epsilon</td><td>This class will automatically collapse epsilon transitions. That means that if the derived class returns a successor for a specific state, this class will query for all epsilon successors of that state recursively and include them all in the successor set. This is costly in terms of performance. </td></tr>
    <tr><td class="paramname">use_cache</td><td>This class will keep a cache of successors for a specific state in a mutable hashmap. This means that the derived class will not be queried twice for the same successor. This can drastically improve performance if the successor computation is expensive. If the successor computation is cheap it should not be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa5e63c54b3eddddaf7b9974035453ccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::initial_states </td>
          <td>(</td>
          <td class="paramtype">State_set &amp;&#160;</td>
          <td class="paramname"><em>states</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Implement</b> Returns the initial states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>A list of states where the initial states must be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bfcf0fd0d14c6494b73da5e991fe488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State_set <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::initial_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a set of initial states. </p>
<dl class="section return"><dt>Returns</dt><dd>State_set The set of initial states. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d6d0723b7cde3bb90ad6a5504fb1aad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::is_epsilon </td>
          <td>(</td>
          <td class="paramtype">const Symbol &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Implement</b> Determines if a symbol should be considered an epsilon transition. </p>
<p>If a symbol is an epsilon transition it means that this symbol will be collapsed and never appear if collapse_epsilon is true. If collapse_epsilon is false the symbol will appear in the counter-example produced by the language inclusion, but the right-hand side will not be advanced on an epsilon transition.</p>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if a symbol should be considered an epsilon transition. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b08886203176cf7f46f27cd30282f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::is_final_state </td>
          <td>(</td>
          <td class="paramtype">const State &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Implement</b> This function determines if a specific state is final. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if state is final, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adc91b4613822227e8550d05257649d66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::is_final_state </td>
          <td>(</td>
          <td class="paramtype">const State_set &amp;&#160;</td>
          <td class="paramname"><em>states</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if one of the states is final. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>A set of states. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True iff any of the states is a final state. </dd></dl>

</div>
</div>
<a class="anchor" id="a07bafc87e4d1bf1a325f819a27f9c26f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::next_symbols </td>
          <td>(</td>
          <td class="paramtype">const State &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Symbol_set &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Implement</b> Returns possible successor symbols for a state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state for which successor symbols should be listed. </td></tr>
    <tr><td class="paramname">symbols</td><td>A set of symbols, where the symbols on the outgoing edges of state should be added. Need not be empty when the function is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a2619ba03fc85cfd9bd99d68f8c8273"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Symbol_set <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::next_symbols </td>
          <td>(</td>
          <td class="paramtype">const State &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns possible successor symbols of a state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Symbol_set The symbols on the outgoing edges of state </dd></dl>

</div>
</div>
<a class="anchor" id="aa04f43b2f0560b17cd07e544567ffb19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdatastructures_1_1printer__base.html">datastructures::printer_base</a>&lt;State&gt;&amp; <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::state_printer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Implement</b> Returns a printer for states. </p>
<p>Ideally the printer is constructed when the automaton is constructed and a reference is returned on each function call. This function may be called frequently and should be marked inline if possible.</p>
<dl class="section return"><dt>Returns</dt><dd>const datastructures::printer_base&lt; State &gt;&amp; A reference to the printer. </dd></dl>

</div>
</div>
<a class="anchor" id="a47d36cd4ad67af0fb989c41ac18d30f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::successors </td>
          <td>(</td>
          <td class="paramtype">const State &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Symbol &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">State_set &amp;&#160;</td>
          <td class="paramname"><em>successors1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Implement</b> Returns the successor for a specific state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state for which the successors should be determined. </td></tr>
    <tr><td class="paramname">sigma</td><td>The symbol indicating the transition that should be followed. </td></tr>
    <tr><td class="paramname">successors1</td><td>The set where the successors should be added. The set need not be empty on function call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd24d2830fb78d22594dd7a41cfea00a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State_set <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::successors </td>
          <td>(</td>
          <td class="paramtype">const State_set &amp;&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Symbol &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds successors for a set of states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>The starting states </td></tr>
    <tr><td class="paramname">sigma</td><td>The symbol we are looking for a successor for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State_set A set of successor states </dd></dl>

</div>
</div>
<a class="anchor" id="a8c737fc524a5231e5aabeadda03d76e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::successors </td>
          <td>(</td>
          <td class="paramtype">const State_set &amp;&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Symbol &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">State_set &amp;&#160;</td>
          <td class="paramname"><em>successors1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns successors for a set of states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>The starting states </td></tr>
    <tr><td class="paramname">sigma</td><td>The symbol we are looking for a successor for </td></tr>
    <tr><td class="paramname">successors1</td><td>Successors are added to this set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b70685fde44d22f1bae00c209fb0b63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State_set <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::successors </td>
          <td>(</td>
          <td class="paramtype">const State &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Symbol &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns successors for a state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state. </td></tr>
    <tr><td class="paramname">sigma</td><td>The symbol for successors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State_set The successors of state for symbol sigma. </dd></dl>

</div>
</div>
<a class="anchor" id="a57a9de347cc7a424b2ce939e11888098"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Symbol, class Implementation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdatastructures_1_1printer__base.html">datastructures::printer_base</a>&lt;Symbol&gt;&amp; <a class="el" href="classautomata_1_1automaton.html">automata::automaton</a>&lt; State, Symbol, Implementation &gt;::symbol_printer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Implement</b> Returns a printer for symbols. </p>
<p>Ideally the printer is constructed when the automaton is constructed and a reference is returned on each function call. This function may be called frequently and should be marked inline if possible.</p>
<dl class="section return"><dt>Returns</dt><dd>const datastructures::printer_base&lt; Symbol &gt;&amp; A reference to the printer. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Limi/<a class="el" href="automaton_8h_source.html">automaton.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 8 2015 15:33:33 for Limi by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
